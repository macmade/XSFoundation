/*******************************************************************************
 * Copyright (c) 2011, Jean-David Gadina <macmade@eosgarden.com>
 * Distributed under the Boost Software License, Version 1.0.
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

/* $Id */

/*!
 * @file        XSString.c
 * @copyright   eosgarden 2011 - Jean-David Gadina <macmade@eosgarden.com>
 * @abstract    ...
 */

#include "XS.h"
#include "__XSString.h"

#define __XSSTRING_DEFAULT_CAPACITY 256

/*!
 * @function    XSString_Create
 * @abstract    Creates an empty string
 * @result      A new string object
 */
XSStringRef XSString_Create( void )
{
    return XSString_CreateWithCapacity( __XSSTRING_DEFAULT_CAPACITY );
}

/*!
 * @function    XSString_CreateWithCapacity
 * @abstract    Creates an empty string with an initial capacity
 * @param       capacity    The initial string capacity
 * @result      A new string object
 */
XSStringRef XSString_CreateWithCapacity( XSUInteger capacity )
{
    XSString * string;
    
    string = __XSString_Alloc();
    
    string->str = XSAlloc( ( sizeof( char ) * capacity ) + 1 );
    
    return ( XSStringRef )string;
}

/*!
 * @function    XSString_CreateWithCString
 * @abstract    Creates a string from a C string
 * @param       The C string
 * @result      A new string object
 */
XSStringRef XSString_CreateWithCString( char * str )
{
    size_t     length;
    XSString * string;
    
    length = strlen( str );
    string = ( XSString * )XSString_CreateWithCapacity( length );
    
    memcpy( string->str, str, length );
    
    string->length = length;
    
    return ( XSStringRef )string;
}

/*!
 * @function    XSString_CreateWithContentOfFile
 * @abstract    Creates a string with a file's content
 * @param       path    The path to the file
 * @result      A new string object
 */
XSStringRef XSString_CreateWithContentOfFile( char * path )
{
    ( void )path;
    
    return NULL;
}

/*!
 * @function    XSString_SubstringFromIndex
 * @abstract    Gets a substring to a specific index
 * @description You are responsible to release the returned string object
 * @param       str     The string object
 * @param       i       The index
 * @result      A new string object
 */
XSStringRef XSString_SubstringFromIndex( XSStringRef str, size_t i )
{
    XSString * _str;
    
    _str = ( XSString * )str;
    
    if( i >= _str->length )
    {
        return NULL;
    }
    
    return XSString_CreateWithCString( _str->str + i );
}

/*!
 * @function    XSString_SubstringToIndex
 * @abstract    Gets a substring to a specific index
 * @description You are responsible to release the returned string object
 * @param       str     The string object
 * @param       i       The index
 * @result      A new string object
 */
XSStringRef XSString_SubstringToIndex( XSStringRef str, size_t i )
{
    XSString * _str;
    XSString * str2;
    
    _str = ( XSString * )str;
    
    if( i >= _str->length )
    {
        return XSCopy( str );
    }
    
    str2 = ( XSString * )XSString_CreateWithCapacity( i + 1 );
    
    memcpy( str2->str, _str->str, i );
    
    return ( XSStringRef )str2;
}

/*!
 * @function    XSString_SubstringWithRange
 * @abstract    Gets a substring within a specific range
 * @description You are responsible to release the returned string object
 * @param       str     The string object
 * @param       range   The range
 * @result      A new string object
 */
XSStringRef XSString_SubstringWithRange( XSStringRef str, XSRange range )
{
    XSString * _str;
    
    _str = ( XSString * )str;
    
    ( void )range;
    
    return NULL;
}

/*!
 * @function    XSString_LowercaseString
 * @abstract    Gets a lower-case string
 * @description You are responsible to release the returned string object
 * @param       str     The string object
 * @result      A new string object
 */
XSStringRef XSString_LowercaseString( XSStringRef str )
{
    XSString * _str;
    size_t     i;
    char       c;
    
    _str = XSCopy( str );
    
    for( i = 0; i < _str->length; i++ )
    {
        c = _str->str[ i ];
        
        if( c >= 0x41 && c <= 0x5A )
        {
            _str->str[ i ] = _str->str[ i ] + 0x20;
        }
    }
    
    return ( XSStringRef)_str;
}

/*!
 * @function    XSString_LowercaseString
 * @abstract    Gets a upper-case string
 * @description You are responsible to release the returned string object
 * @param       str     The string object
 * @result      A new string object
 */
XSStringRef XSString_UppercaseString( XSStringRef str )
{
    XSString * _str;
    size_t     i;
    char       c;
    
    _str = XSCopy( str );
    
    for( i = 0; i < _str->length; i++ )
    {
        c = _str->str[ i ];
        
        if( c >= 0x61 && c <= 0x7A )
        {
            _str->str[ i ] = _str->str[ i ] - 0x20;
        }
    }
    
    return ( XSStringRef)_str;
}

/*!
 * @function    XSString_StringByAppendingString
 * @abstract    Creates a new string by appending an other string
 * @description You are responsible to release the returned string object
 * @param       str1    The string object
 * @param       str2    The string to append
 * @result      A new string object
 */
XSStringRef XSString_StringByAppendingString( XSStringRef str1, XSStringRef str2 )
{
    XSString * str;
    size_t     length1;
    size_t     length2;
    
    length1 = XSString_Length( str1 );
    length2 = XSString_Length( str2 );
    
    str = ( XSString * )XSString_CreateWithCapacity( length1 + length2 + 1 );
    
    str->length = length1 + length2;
    
    memset( str->str, 0, str->length + 1 );
    memcpy( str->str, ( ( XSString * )str1 )->str, length1 );
    strcat( str->str, ( ( XSString * )str2 )->str );
    
    return ( XSStringRef )str;
}

/*!
 * @function    XSString_StringByAppendingCString
 * @abstract    Creates a new string by appending an C string
 * @description You are responsible to release the returned string object
 * @param       str1    The string object
 * @param       str2    The C string to append
 * @result      A new string object
 */
XSStringRef XSString_StringByAppendingCString( XSStringRef str1, char * str2 )
{
    XSString * str;
    size_t     length1;
    size_t     length2;
    
    length1 = XSString_Length( str1 );
    length2 = strlen( str2 );
    
    str = ( XSString * )XSString_CreateWithCapacity( length1 + length2 + 1 );
    
    str->length = length1 + length2;
    
    memset( str->str, 0, str->length + 1 );
    memcpy( str->str, ( ( XSString * )str1 )->str, length1 );
    strcat( str->str, str2 );
    
    return ( XSStringRef )str;
}

/*!
 * @function    XSString_Length
 * @abstract    Gets the string length
 * @param       str     The string object
 * @result      A new string length
 */
size_t XSString_Length( XSStringRef str )
{
    return ( ( XSString * )str )->length;
}

/*!
 * @function    XSString_CharacterAtIndex
 * @abstract    Gets a character at a specific index
 * @param       str     The string object
 * @param       i       The index
 * @result      The character
 */
char XSString_CharacterAtIndex( XSStringRef str, size_t i )
{
    XSString * _str;
    
    _str = ( XSString * )str;
    
    if( i >= _str->length )
    {
        return 0;
    }
    
    return _str->str[ i ];
}

/*!
 * @function    XSString_CString
 * @abstract    Gets the C string
 * @param       str     The string object
 * @result      The C String
 */
const char * XSString_CString( XSStringRef str )
{
    return ( ( XSString * )str )->str;
}

/*!
 * @function    XSString_RangeOfString
 * @abstract    Gets the range of a string in the string
 * @description If the C string is not found, the location field of the range
 *              will equals XSNotFound.
 * @param       str     The string object
 * @result      The range of the string
 */
XSRange XSString_RangeOfString( XSStringRef str1, XSStringRef str2 )
{
    XSString * _str1;
    XSString * _str2;
    XSRange    range;
    
    _str1 = ( XSString * )str1;
    _str2 = ( XSString * )str2;
    range = XSMakeRange( 0, 0 );
    
    ( void )str1;
    ( void )str2;
    
    return range;
}

/*!
 * @function    XSString_RangeOfCString
 * @abstract    Gets the range of a C string in the string
 * @description If the C string is not found, the location field of the range
 *              will equals XSNotFound.
 * @param       str     The string object
 * @result      The range of the C string
 */
XSRange XSString_RangeOfCString( XSStringRef str1, char * str2 )
{
    XSString * _str;
    XSRange    range;
    
    _str  = ( XSString * )str1;
    range = XSMakeRange( 0, 0 );
    
    ( void )str2;
    
    return range;
}

/*!
 * @function    XSString_IsEqualToString
 * @abstract    Compares the string with another string
 * @param       str     The string object
 * @result      YES if both strings are equals, otherwise NO
 */
BOOL XSString_IsEqualToString( XSStringRef str1, XSStringRef str2 )
{
    XSString * _str1;
    XSString * _str2;
    
    _str1 = ( XSString * )str1;
    _str2 = ( XSString * )str2;
    
    if( strcmp( _str1->str, _str2->str ) == 0 )
    {
        return YES;
    }
    
    return NO;
}

/*!
 * @function    XSString_StringByReplacingStringWithString
 * @abstract    Replaces the occurences of a string with another string
 * @description You are responsible to release the returned string object
 * @param       str     The string object
 * @result      A new string object
 */
XSStringRef XSString_StringByReplacingStringWithString( XSStringRef str1, XSStringRef str2, XSStringRef str3 )
{
    XSString * _str1;
    XSString * _str2;
    XSString * _str3;
    
    _str1 = ( XSString * )str1;
    _str2 = ( XSString * )str2;
    _str3 = ( XSString * )str3;
    
    return NULL;
}

/*!
 * @function    XSString_IntegerValue
 * @abstract    Converts the string to an integer representation
 * @param       str     The string object
 * @result      An integer value
 */
XSInteger XSString_IntegerValue( XSStringRef str )
{
    XSString * _str;
    
    _str = ( XSString * )str;
    
    return 0;
}

/*!
 * @function    XSString_FloatValue
 * @abstract    Converts the string to a floating point representation
 * @param       str     The string object
 * @result      A floating point value
 */
XSFloat XSString_FloatValue( XSStringRef str )
{
    XSString * _str;
    
    _str = ( XSString * )str;
    
    return 0;
}
