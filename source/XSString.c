/*******************************************************************************
 * Copyright (c) 2011, Jean-David Gadina <macmade@eosgarden.com>
 * Distributed under the Boost Software License, Version 1.0.
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

/* $Id */

/*!
 * @file        XSString.c
 * @copyright   eosgarden 2011 - Jean-David Gadina <macmade@eosgarden.com>
 * @abstract    ...
 */

#include "XS.h"
#include "__XSString.h"

#define __XSSTRING_DEFAULT_CAPACITY 256

/*!
 * @function    XSString_Create
 * @abstract    Creates an empty string
 * @result      A new string object
 */
XSString XSString_Create( void )
{
    return XSString_CreateWithCapacity( __XSSTRING_DEFAULT_CAPACITY );
}

/*!
 * @function    XSString_CreateWithCapacity
 * @abstract    Creates an empty string with an initial capacity
 * @param       capacity    The initial string capacity
 * @result      A new string object
 */
XSString XSString_CreateWithCapacity( XSUInteger capacity )
{
    __XSString * string;
    
    string = __XSString_Alloc();
    
    if( capacity == 0 )
    {
        capacity = __XSSTRING_DEFAULT_CAPACITY;
    }
    
    string->str = XSAlloc( ( sizeof( char ) * capacity ) + 1 );
    
    return ( XSString )string;
}

/*!
 * @function    XSString_CreateWithCString
 * @abstract    Creates a string from a C string
 * @param       The C string
 * @result      A new string object
 */
XSString XSString_CreateWithCString( char * str )
{
    size_t       length;
    __XSString * string;
    
    if( str == NULL )
    {
        return XSString_Create();
    }
    
    length = strlen( str );
    string = ( __XSString * )XSString_CreateWithCapacity( length );
    
    memcpy( string->str, str, length );
    
    string->length = length;
    
    return ( XSString )string;
}

/*!
 * @function    XSString_CreateWithContentOfFile
 * @abstract    Creates a string with a file's content
 * @param       path    The path to the file
 * @result      A new string object
 */
XSString XSString_CreateWithContentOfFile( char * path )
{
    ( void )path;
    
    return NULL;
}

/*!
 * @function    XSString_SubstringFromIndex
 * @abstract    Gets a substring to a specific index
 * @description You are responsible to release the returned string object
 * @param       str     The string object
 * @param       i       The index
 * @result      A new string object
 */
XSString XSString_SubstringFromIndex( XSString str, size_t i )
{
    __XSString * _str;
    
    if( str == NULL )
    {
        return NULL;
    }
    
    _str = ( __XSString * )str;
    
    if( i >= _str->length )
    {
        return NULL;
    }
    
    return XSString_CreateWithCString( _str->str + i );
}

/*!
 * @function    XSString_SubstringToIndex
 * @abstract    Gets a substring to a specific index
 * @description You are responsible to release the returned string object
 * @param       str     The string object
 * @param       i       The index
 * @result      A new string object
 */
XSString XSString_SubstringToIndex( XSString str, size_t i )
{
    __XSString * _str;
    __XSString * str2;
    
    if( str == NULL )
    {
        return NULL;
    }
    
    _str = ( __XSString * )str;
    
    if( i >= _str->length )
    {
        return XSCopy( str );
    }
    
    str2 = ( __XSString * )XSString_CreateWithCapacity( i + 1 );
    
    memcpy( str2->str, _str->str, i );
    
    return ( XSString )str2;
}

/*!
 * @function    XSString_SubstringWithRange
 * @abstract    Gets a substring within a specific range
 * @description You are responsible to release the returned string object
 * @param       str     The string object
 * @param       range   The range
 * @result      A new string object
 */
XSString XSString_SubstringWithRange( XSString str, XSRange range )
{
    __XSString * _str1;
    __XSString * _str2;
    
    if( str == NULL )
    {
        return NULL;
    }
    
    _str1 = ( __XSString * )str;
    
    if( range.location > _str1->length )
    {
        return NULL;
    }
    
    if( range.length > _str1->length - range.location )
    {
        range.length = _str1->length - range.location;
    }
    
    _str2 = ( __XSString * )XSString_CreateWithCapacity( range.length + 1 );
    
    memset( _str2->str, 0, range.length + 1 );
    memcpy( _str2->str, ( _str1->str ) + range.location, range.length );
    
    return ( XSString )_str2;
}

/*!
 * @function    XSString_LowercaseString
 * @abstract    Gets a lower-case string
 * @description You are responsible to release the returned string object
 * @param       str     The string object
 * @result      A new string object
 */
XSString XSString_LowercaseString( XSString str )
{
    __XSString * _str;
    size_t       i;
    char         c;
    
    if( str == NULL )
    {
        return NULL;
    }
    
    _str = XSCopy( str );
    
    for( i = 0; i < _str->length; i++ )
    {
        c = _str->str[ i ];
        
        if( c >= 0x41 && c <= 0x5A )
        {
            _str->str[ i ] = _str->str[ i ] + 0x20;
        }
    }
    
    return ( XSString)_str;
}

/*!
 * @function    XSString_LowercaseString
 * @abstract    Gets a upper-case string
 * @description You are responsible to release the returned string object
 * @param       str     The string object
 * @result      A new string object
 */
XSString XSString_UppercaseString( XSString str )
{
    __XSString * _str;
    size_t       i;
    char         c;
    
    if( str == NULL )
    {
        return NULL;
    }
    
    _str = XSCopy( str );
    
    for( i = 0; i < _str->length; i++ )
    {
        c = _str->str[ i ];
        
        if( c >= 0x61 && c <= 0x7A )
        {
            _str->str[ i ] = _str->str[ i ] - 0x20;
        }
    }
    
    return ( XSString)_str;
}

/*!
 * @function    XSString_StringByAppendingString
 * @abstract    Creates a new string by appending an other string
 * @description You are responsible to release the returned string object
 * @param       str1    The string object
 * @param       str2    The string to append
 * @result      A new string object
 */
XSString XSString_StringByAppendingString( XSString str1, XSString str2 )
{
    __XSString * str;
    size_t       length1;
    size_t       length2;
    
    if( str1 == NULL )
    {
        return NULL;
    }
    
    if( str2 == NULL )
    {
        return XSCopy( str1 );
    }
    
    length1 = XSString_Length( str1 );
    length2 = XSString_Length( str2 );
    
    str = ( __XSString * )XSString_CreateWithCapacity( length1 + length2 + 1 );
    
    str->length = length1 + length2;
    
    memset( str->str, 0, str->length + 1 );
    memcpy( str->str, ( ( __XSString * )str1 )->str, length1 );
    strcat( str->str, ( ( __XSString * )str2 )->str );
    
    return ( XSString )str;
}

/*!
 * @function    XSString_StringByAppendingCString
 * @abstract    Creates a new string by appending an C string
 * @description You are responsible to release the returned string object
 * @param       str1    The string object
 * @param       str2    The C string to append
 * @result      A new string object
 */
XSString XSString_StringByAppendingCString( XSString str1, char * str2 )
{
    __XSString * str;
    size_t       length1;
    size_t       length2;
    
    if( str1 == NULL )
    {
        return NULL;
    }
    
    if( str2 == NULL )
    {
        return XSCopy( str1 );
    }
    
    length1 = XSString_Length( str1 );
    length2 = strlen( str2 );
    
    str = ( __XSString * )XSString_CreateWithCapacity( length1 + length2 + 1 );
    
    str->length = length1 + length2;
    
    memset( str->str, 0, str->length + 1 );
    memcpy( str->str, ( ( __XSString * )str1 )->str, length1 );
    strcat( str->str, str2 );
    
    return ( XSString )str;
}

/*!
 * @function    XSString_Length
 * @abstract    Gets the string length
 * @param       str     The string object
 * @result      A new string length
 */
size_t XSString_Length( XSString str )
{
    if( str == NULL )
    {
        return 0;
    }
    
    return ( ( __XSString * )str )->length;
}

/*!
 * @function    XSString_CharacterAtIndex
 * @abstract    Gets a character at a specific index
 * @param       str     The string object
 * @param       i       The index
 * @result      The character
 */
char XSString_CharacterAtIndex( XSString str, size_t i )
{
    __XSString * _str;
    
    if( str == NULL )
    {
        return 0;
    }
    
    _str = ( __XSString * )str;
    
    if( i >= _str->length )
    {
        return 0;
    }
    
    return _str->str[ i ];
}

/*!
 * @function    XSString_CString
 * @abstract    Gets the C string
 * @param       str     The string object
 * @result      The C String
 */
const char * XSString_CString( XSString str )
{
    if( str == NULL )
    {
        return NULL;
    }
    
    return ( ( __XSString * )str )->str;
}

/*!
 * @function    XSString_RangeOfString
 * @abstract    Gets the range of a string in the string
 * @description If the C string is not found, the location field of the range
 *              will equals XSNotFound.
 * @param       str     The string object
 * @result      The range of the string
 */
XSRange XSString_RangeOfString( XSString str1, XSString str2 )
{
    XSString * _str1;
    XSString * _str2;
    XSRange    range;
    
    if( str1 == NULL || str2 == NULL )
    {
        return XSMakeRange( XSNotFound, 0 );
    }
    
    _str1 = ( XSString * )str1;
    _str2 = ( XSString * )str2;
    range = XSMakeRange( 0, 0 );
    
    ( void )str1;
    ( void )str2;
    
    return range;
}

/*!
 * @function    XSString_RangeOfCString
 * @abstract    Gets the range of a C string in the string
 * @description If the C string is not found, the location field of the range
 *              will equals XSNotFound.
 * @param       str     The string object
 * @result      The range of the C string
 */
XSRange XSString_RangeOfCString( XSString str1, char * str2 )
{
    XSString * _str;
    XSRange    range;
    
    if( str1 == NULL || str2 == NULL )
    {
        return XSMakeRange( XSNotFound, 0 );
    }
    
    _str  = ( XSString * )str1;
    range = XSMakeRange( 0, 0 );
    
    ( void )str2;
    
    return range;
}

/*!
 * @function    XSString_IsEqualToString
 * @abstract    Compares the string with another string
 * @param       str     The string object
 * @result      YES if both strings are equals, otherwise NO
 */
BOOL XSString_IsEqualToString( XSString str1, XSString str2 )
{
    __XSString * _str1;
    __XSString * _str2;
    
    if( str1 == NULL || str2 == NULL )
    {
        return NO;
    }
    
    _str1 = ( __XSString * )str1;
    _str2 = ( __XSString * )str2;
    
    if( strcmp( _str1->str, _str2->str ) == 0 )
    {
        return YES;
    }
    
    return NO;
}

/*!
 * @function    XSString_StringByReplacingStringWithString
 * @abstract    Replaces the occurences of a string with another string
 * @description You are responsible to release the returned string object
 * @param       str     The string object
 * @result      A new string object
 */
XSString XSString_StringByReplacingStringWithString( XSString str1, XSString str2, XSString str3 )
{
    XSString * _str1;
    XSString * _str2;
    XSString * _str3;
    
    _str1 = ( XSString * )str1;
    _str2 = ( XSString * )str2;
    _str3 = ( XSString * )str3;
    
    return NULL;
}

/*!
 * @function    XSString_IntegerValue
 * @abstract    Converts the string to an integer representation
 * @param       str     The string object
 * @result      An integer value
 */
XSInteger XSString_IntegerValue( XSString str )
{
    XSString * _str;
    
    _str = ( XSString * )str;
    
    return 0;
}

/*!
 * @function    XSString_FloatValue
 * @abstract    Converts the string to a floating point representation
 * @param       str     The string object
 * @result      A floating point value
 */
XSFloat XSString_FloatValue( XSString str )
{
    XSString * _str;
    
    _str = ( XSString * )str;
    
    return 0;
}
