/*******************************************************************************
 * Copyright (c) 2011, Jean-David Gadina <macmade@eosgarden.com>
 * Distributed under the Boost Software License, Version 1.0.
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/
 
/* $Id$ */

/*!
 * @file        XSFile.c
 * @copyright   eosgarden 2011 - Jean-David Gadina <macmade@eosgarden.com>
 * @abstract    ...
 */

#include "XS.h"
#include "__XSFile.h"

/*!
 * @var         __XSSStdin
 * @abstract    XSFile structure representing stdin
 */
XSFile __XSSStdin   = { .stdin  = YES, .need_init = YES };

/*!
 * @var         __XSSStdout
 * @abstract    XSFile structure representing srdout
 */
XSFile __XSSStdout  = { .stdout = YES, .need_init = YES };

/*!
 * @var         __XSSStderr
 * @abstract    XSFile structure representing stderr
 */
XSFile __XSSStderr  = { .stderr = YES, .need_init = YES };

/*!
 * @var         XSStdin
 * @abstract    XSFileRef object representing stdin
 */
XSFileRef XSStdin   = ( XSFileRef )&__XSSStdin;

/*!
 * @var         XSStdout
 * @abstract    XSFileRef object representing stdout
 */
XSFileRef XSSStdout = ( XSFileRef )&__XSSStderr;

/*!
 * @var         XSStderr
 * @abstract    XSFileRef object representing stderr
 */
XSFileRef XSSStderr = ( XSFileRef )&__XSSStderr;

/*!
 * @define      __XSFILE_INIT
 * @abstract    File initialization macro
 * @description This is needed for stdin, stdout and sterr, in order to
 *              initialize properly XSStdin, XSStdout and XSStderr.
 */
#define __XSFILE_INIT( f )          \
if( f->need_init == YES )           \
{                                   \
    if( f->stdin == YES )           \
    {                               \
        f->fp        = stdin;       \
        f->need_init = NO;          \
    }                               \
    else if( f->stdout == YES )     \
    {                               \
        f->fp        = stdout;      \
        f->need_init = NO;          \
    }                               \
    else if( f->stderr == YES )     \
    {                               \
        f->fp        = stderr;      \
        f->need_init = NO;          \
    }                               \
}

/*!
 * @abstract    Creates an XSFileRef instance and opens the represented file.
 * @description This function may return NULL if the represented file has not
 *              been opened.
 * @param       filename    The name of the file
 * @param       mode        The file open mode (see XSFileOpenMode)
 * @result      The instance of XSFileRef
 */
XSFileRef XSFile_Open( const char * filename, XSFileOpenMode openMode )
{
    FILE    * fp;
    XSFile  * file;
    char      mode[ 4 ];
    BOOL      binary;
    
    memset( mode, 0, 4 );
    
    binary   = ( openMode & XSFileOpenModeBinary ) ? YES : NO;
    openMode = openMode & 0xFE;
    
    switch( ( int )openMode )
    {
        case XSFileOpenModeRead:
            
            strcat( mode, ( binary ) ? "rb" : "r" );
            break;
            
        case XSFileOpenModeWrite:
            
            strcat( mode, ( binary ) ? "wb" : "r" );
            break;
            
        case XSFileOpenModeAppend:
            
            strcat( mode, ( binary ) ? "ab" : "r" );
            break;
            
        case XSFileOpenModeApendAtEnd:
            
            strcat( mode, ( binary ) ? "ab+" : "a" );
            break;
            
        case XSFileOpenModeUpdate:
            
            strcat( mode, ( binary ) ? "rb+" : "r+" );
            break;
            
        case XSFileOpenModeUpdateDiscard:
            
            strcat( mode, ( binary ) ? "wb+" : "w+" );
            break;
    }
    
    if( binary )
    {
        strcat( mode, "b" );
    }
    
    if( NULL == ( fp = fopen( filename, mode ) ) )
    {
        return NULL;
    }
    
    if( NULL == ( file = __XSFile_Alloc() ) )
    {
        return NULL;
    }
    
    file->fp = fp;
    
    memset(  file->filename,      0, FILENAME_MAX );
    memset(  file->mode,          0, 4 );
    memset(  &( file->stat_buf ), 0, sizeof( struct stat ) );
    strcpy(  file->filename, filename );
    strncpy( file->mode, mode, 3 );
    __XSFile_UpdateStat( file );
    
    file->need_init  = NO;
    file->bit_buffer = 0;
    file->bit_count  = 0;
    file->bit_offset = 0;
    file->readable   = NO;
    file->writeable  = NO;
    
    if( strncmp( mode, "r", 1 ) == 0 )
    {
        file->readable  = YES;
        file->writeable = ( strlen( mode ) > 1 && strncmp( mode + 1, "+", 1 ) ) ? YES : NO;
    }
    else if( strncmp( mode, "w", 1 ) == 0 )
    {
        file->readable  = ( strlen( mode ) > 1 && strncmp( mode + 1, "+", 1 ) ) ? YES : NO;
        file->writeable = YES;
    }
    else if( strncmp( mode, "a", 1 ) == 0 )
    {
        file->readable  = ( strlen( mode ) > 1 && strncmp( mode + 1, "+", 1 ) ) ? YES : NO;
        file->writeable = YES;
    }
    
    return ( XSFileRef )file;
}

/*!
 * @function    
 * @abstract    Flushes the file stream stream
 * @param       file    The file object
 * @result      Zero on success or EOF on error
 */
XSInteger XSFile_Flush( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    __XSFILE_INIT( _f );
    
    return fflush( _f->fp );
}

/*!
 * @function    XSFile_Close
 * @abstract    Closes the file stream (after flushing, if output stream)
 * @discussion  You're still responsible to release the file object after
 *              calling this function.
 * @param       file    The file object
 * @result      EOF on error, zero otherwise.
 */
XSInteger XSFile_Close( XSFileRef file )
{
    XSInteger res;
    XSFile *  _f;
    
    _f = ( XSFile * )file;
    
    __XSFile_WriteAlign( _f );
    
    res = fclose( _f->fp );
    
    XSRelease( _f );
    
    return res;
}

/*!
 * @function    XSFile_Printf
 * @abstract    Converts (according to format format) and writes output to the file
 * @param       file    The file object
 * @result      The number of characters written, or negative value on error
 */
XSInteger XSFile_Printf( XSFileRef file, const char * format, ... )
{
    XSInteger res;
    va_list   arg;
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    __XSFILE_INIT( _f );
    __XSFile_WriteAlign( _f );
    
    va_start( arg, format );
    
    res = vfprintf( _f->fp, format, arg );
    
    va_end( arg );
    
    return res;
}

/*!
 * @function    XSFile_VPrintf
 * @abstract    Equivalent to fprintf with variable argument list replaced by arg.
 * @param       file    The file object
 * @param       arg     The variable arguments list
 * @result      The number of characters written, or negative value on error
 */
XSInteger XSFile_VPrintf( XSFileRef file, const char * format, va_list arg )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    __XSFILE_INIT( _f );
    __XSFile_WriteAlign( _f );
    
    return vfprintf( _f->fp, format, arg );
}

/*!
 * @function    XSFile_Getc
 * @abstract    Returns the next character from the file.
 * @param       file    The file object
 * @result      The character or EOF on error
 */
XSInteger XSFile_Getc( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    __XSFILE_INIT( _f );
    
    return fgetc( _f->fp );
}

/*!
 * @function    XSFile_Putc
 * @abstract    Writes a character to the file
 * @param       file    The file object
 * @param       c       The character to write
 * @result      The character or EOF on error
 */
XSInteger XSFile_Putc( XSFileRef file, XSInteger c )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    __XSFILE_INIT( _f );
    __XSFile_WriteAlign( _f );
    
    return fputc( c, _f->fp );
}

/*!
 * @function    XSFile_Puts
 * @abstract    Writes a C string to the file
 * @param       file    The file object
 * @result      Non-negative on success or EOF on error.
 */
XSInteger XSFile_Puts( XSFileRef file, const char * s )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    __XSFILE_INIT( _f );
    __XSFile_WriteAlign( _f );
    
    return fputs( s, _f->fp );
}

/*!
 * @function    XSFile_Read
 * @abstract    Reads from the file
 * @param       file    The file object
 * @param       ptr     A pointer to the memory location in which the data will be placed.
 * @param       file    The size of the objects to read
 * @param       file    The number of objects to read
 * @result      The number of objects read
 */
size_t XSFile_Read( XSFileRef file, void * ptr, size_t size, size_t nobj )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    __XSFILE_INIT( _f );
    
    return fread( ptr, size, nobj, _f->fp );
}

/*!
 * @function    XSFile_Write
 * @abstract    Writes to the file
 * @param       file    The file object
 * @param       ptr     The data to write
 * @param       file    The size of the objects to write
 * @param       file    The number of objects to write
 * @result      The number of objects written
 */
size_t XSFile_Write( XSFileRef file, const void * ptr, size_t size, size_t nobj )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    __XSFILE_INIT( _f );
    __XSFile_WriteAlign( _f );
    
    return fwrite( ptr, size, nobj, _f->fp );
}

/*!
 * @function    XSFile_Seek
 * @abstract    Sets file position for the file and clears end-of-file indicator
 * @description For a binary stream, file position is set to offset bytes from
 *              the position indicated by origin: beginning of file for
 *              SEEK_SET, current position for SEEK_CUR, or end of file for
 *              SEEK_END. Behaviour is similar for a text stream, but offset
 *              must be zero or, for SEEK_SET only, a value returned by ftell.
 * @param       file    The file object
 * @param       origin  The seek origin (see XSFileSeekPosition)
 * @result      Non-zero on error.
 */
XSInteger XSFile_Seek( XSFileRef file, XSInteger offset, XSFileSeekPosition origin )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    __XSFILE_INIT( _f );
    
    return fseek( _f->fp, offset, origin );
}

/*!
 * @function    XSFile_Tell
 * @abstract    Gets the current file position
 * @param       file    The file object
 * @result      The position or -1 on error
 */
XSInteger XSFile_Tell( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    __XSFILE_INIT( _f );
    
    return ftell( _f->fp );
}

/*!
 * @function    XSFile_Rewind
 * @abstract    Rewinds to the beginning of the file and clears the error indicators
 * return       void
 */
void XSFile_Rewind( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    __XSFILE_INIT( _f );
    
    rewind( _f->fp );
}

/*!
 * @function    XSFile_GetPos
 * @abstract    Stores current file position
 * @param       file    The file object
 * @param       ptr     A pointer where tos store the file position
 * @result      Non-zero on error
 */
XSInteger XSFile_GetPos( XSFileRef file, fpos_t * ptr )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    __XSFILE_INIT( _f );
    
    return fgetpos( _f->fp, ptr );
}

/*!
 * @function    XSFile_SetPos
 * @abstract    Sets the current file position
 * @param       file    The file object
 * @param       ptr     The file position
 * @result      Non-zero on error
 */
XSInteger XSFile_SetPos( XSFileRef file, const fpos_t * ptr )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    __XSFILE_INIT( _f );
    
    return fsetpos( _f->fp, ptr );
}

/*!
 * @function    XSFile_ClearErr
 * @abstract    Clears end-of-file and error indicators
 * @param       file    The file object
 * @result      void
 */
void XSFile_ClearErr( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    __XSFILE_INIT( _f );
    
    clearerr( _f->fp );
}

/*!
 * @function    XSFile_EndOfFile
 * @abstract    Checks for the end of the file
 * @param       file    The file object
 * @result      Non-zero if end-of-file indicator is set
 */
XSInteger XSFile_EndOfFile( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    __XSFILE_INIT( _f );
    
    return feof( _f->fp );
}

/*!
 * @function    XSFile_Error
 * @abstract    Checks for the error indicator
 * @param       file    The file object
 * @result      Non-zero if error indicator is set
 */
XSInteger XSFile_Error( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    __XSFILE_INIT( _f );
    
    return ferror( _f->fp );
}

/*!
 * @function    XSFile_Filename
 * @abstract    Gets the filename
 * @param       file    The file object
 * @result      The name of the file
 */
const char * XSFile_Filename( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    __XSFILE_INIT( _f );
    
    if( _f->stdin == YES )
    {
        return "stdin";
    }
    else if( _f->stdout == YES )
    {
        return "stdout";
    }
    else if( _f->stderr == YES )
    {
        return "stderr";
    }
    else
    {
        return _f->filename;
    }
}

/*!
 * @function    XSFile_OpenMode
 * @abstract    Gets the file's open mode
 * @param       file    The file object
 * @result      The file's open mode
 */
const char * XSFile_OpenMode( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    __XSFILE_INIT( _f );
    
    if( _f->stdin == YES )
    {
        return "r";
    }
    else if( _f->stdout == YES )
    {
        return "a";
    }
    else if( _f->stderr == YES )
    {
        return "a";
    }
    else
    {
        return _f->mode;
    }
}

/*!
 * @function    XSFile_IsReadable
 * @abstract    Checks if the file is readable 
 * @param       file    The file object
 * @result      true if the file is readable, otherwise false
 */
BOOL XSFile_IsReadable( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    __XSFILE_INIT( _f );
    
    if( _f->stdin == true )
    {
        return YES;
    }
    else if( _f->stdout == true )
    {
        return NO;
    }
    else if( _f->stderr == true )
    {
        return NO;
    }
    else
    {
        return _f->readable;
    }
}

/*!
 * @function    XSFile_IsWriteable
 * @abstract    Checks if the file is writeable 
 * @param       file    The file object
 * @result      true if the file is writeable, otherwise false
 */
BOOL XSFile_IsWriteable( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    __XSFILE_INIT( _f );
    
    if( _f->stdin == true )
    {
        return NO;
    }
    else if( _f->stdout == true )
    {
        return YES;
    }
    else if( _f->stderr == true )
    {
        return YES;
    }
    else
    {
        return _f->writeable;
    }
}

/*!
 * @function    XSFile_Copy
 * @abstract    Copies the file to another destination
 * @param       file    The file object
 * @result      True if the file was copeid, otherwise false
 */
BOOL XSFile_Copy( XSFileRef file, char * new_name )
{
    FILE        * fp1;
    FILE        * fp2;
    size_t        length;
    unsigned char buffer[ 1024 ];
    const char  * name;
    
    name = XSFile_Filename( file );
    
    if( NULL == ( fp1 = fopen( name, "rb" ) ) )
    {
        return NO;
    }
    
    if( NULL == ( fp2 = fopen( name, "wb" ) ) )
    {
        fclose( fp1 );
        
        return NO;
    }
    
    while( ( length = fread( buffer, sizeof( unsigned char ), 1024, fp1 ) ) )
    {
        if( fwrite( buffer, sizeof( unsigned char ), length, fp2 ) != length )
        {
            fclose( fp1 );
            fclose( fp2 );
            remove( new_name );
            
            return NO;
        }
    }
    
    fclose( fp1 );
    fclose( fp2 );
    
    return YES;
}

XSInteger XSFile_GetBit( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    if( _f->readable == false )
    {
        return 0;
    }
    
    _f->bit_offset++;
    _f->bit_offset++;
    
    if( _f->bit_offset > 8 )
    {
        if( fread( &( _f->bit_buffer ), sizeof( char ), 1, _f->fp ) != 1 )
        {
            _f->bit_offset = 1;
            
            return -1;
        }
    }
    
    return ( _f->bit_buffer >> ( 8 - _f->bit_offset ) & 1 );
}

XSInteger XSFile_PutBit( XSFileRef file, uint8_t bit )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    if( _f->writeable == false )
    {
        return -1;
    }
    
    _f->bit_buffer |= ( _f->bit_buffer << 1 | ( bit & 1 ) );
    _f->bit_count  += 1;
    
    if( _f->bit_count == 8 )
    {
        __XSFile_WriteAlign( _f );
    }
    
    return 0;
}

XSInteger XSFile_GetBits( XSFileRef file, XSUInteger count )
{
    XSInteger  bits;
    XSUInteger i;
    XSFile   * _f;
    
    _f = ( XSFile * )file;
    
    if( _f->readable == false )
    {
        return -1;
    }
    
    bits = 0;
    
    for( i = 0; i < count; i++ )
    {
        bits |= ( ( bits << 1 ) | XSFile_GetBit( file ) );
    }
    
    return bits;
}

XSInteger XSFile_PutBits( XSFileRef file, uint64_t bits, XSUInteger count )
{
    XSUInteger i;
    XSUInteger bytes;
    uint8_t    bit;
    XSFile   * _f;
    
    _f = ( XSFile * )file;
    
    if( _f->writeable == false )
    {
        return -1;
    }
    
    bytes  = ( XSUInteger )floor( count / 8 );
    count -= bytes * 8;
    
    if( bytes > 0 )
    {
        fwrite( &bits, sizeof( uint8_t ), bytes, _f->fp );
    }
    
    bits &= 0xFF;
    
    for( i = 0; i < count; i++ )
    {
        bit = bits >> ( ( count - 1 ) - i );
        
        XSFile_PutBit( file, bit );
    }
    
    return 0;
}

dev_t XSFile_DeviceID( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    return _f->stat_buf.st_dev;
}

ino_t XSFile_SerialNumber( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    return _f->stat_buf.st_ino;
}

nlink_t XSFile_NumberOfLinks( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    return _f->stat_buf.st_nlink;
}

uid_t XSFile_UID( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    return _f->stat_buf.st_uid;
}

gid_t XSFile_GID( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    return _f->stat_buf.st_gid;
}

size_t XSFile_Size( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    __XSFile_UpdateStat( _f );
    
    return _f->stat_buf.st_size;
}

XSFloat XSFile_HumanReadableSize( XSFileRef file, char unit[] )
{
    size_t   bytes;
    XSFloat  size;
    XSFile * _f;
    
    _f    = ( XSFile * )file;
    bytes = XSFile_Size( file );
    
    memset( unit, 0, 3 );
    
    if( bytes < 1000000 )
    {
        size = ( XSFloat )bytes / ( XSFloat )1000;
        
        strcpy( unit, "KB" );
    }
    else if( bytes < 1000000000 )
    {
        size = ( ( XSFloat )bytes / ( XSFloat )1000 ) / ( XSFloat )1000;
        
        strcpy( unit, "MB" );
    }
    else
    {
        size = ( ( ( XSFloat )bytes / ( XSFloat )1000 ) / ( XSFloat )1000 ) / ( XSFloat )1000;
        
        strcpy( unit, "GB" );
    }
    
    return size;
}

time_t XSFile_AccessTime( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    return _f->stat_buf.st_atime;
}

time_t XSFile_ModifictaionTime( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    return _f->stat_buf.st_mtime;
}

time_t XSFile_CreationTime( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    return _f->stat_buf.st_ctime;
}

BOOL XSFile_IsBlockDevice( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    return ( ( ( _f->stat_buf.st_mode & S_IFMT ) == S_IFBLK ) ) ? YES : NO;
}

BOOL XSFile_IsCharacterDevice( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    return ( ( ( _f->stat_buf.st_mode & S_IFMT ) == S_IFCHR ) ) ? YES : NO;
}

BOOL XSFile_IsFIFO( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    return ( ( ( _f->stat_buf.st_mode & S_IFMT ) == S_IFIFO ) ) ? YES : NO;
}

BOOL XSFile_IsRegularFile( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    return ( ( ( _f->stat_buf.st_mode & S_IFMT ) == S_IFREG ) ) ? YES : NO;
}

BOOL XSFile_IsDirectory( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    return ( ( ( _f->stat_buf.st_mode & S_IFMT ) == S_IFDIR ) ) ? YES : NO;
}

BOOL XSFile_IsLink( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    return ( ( ( _f->stat_buf.st_mode & S_IFMT ) == S_IFLNK ) ) ? YES : NO;
}

BOOL XSFile_IsSocket( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    return ( ( ( _f->stat_buf.st_mode & S_IFMT ) == S_IFSOCK ) ) ? YES : NO;
}

BOOL XSFile_IsUserReadable( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    return ( ( ( _f->stat_buf.st_mode & S_IRWXU ) == S_IRUSR ) ) ? YES : NO;
}

BOOL XSFile_IsUserWriteable( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    return ( ( ( _f->stat_buf.st_mode & S_IRWXU ) == S_IWUSR ) ) ? YES : NO;
}

BOOL XSFile_ISUserExecutable( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    return ( ( ( _f->stat_buf.st_mode & S_IRWXU ) == S_IXUSR ) ) ? YES : NO;
}

BOOL XSFile_IsGroupReadable( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    return ( ( ( _f->stat_buf.st_mode & S_IRWXG ) == S_IRGRP ) ) ? YES : NO;
}

BOOL XSFile_IsGroupWriteable( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    return ( ( ( _f->stat_buf.st_mode & S_IRWXG ) == S_IWGRP ) ) ? YES : NO;
}

BOOL XSFile_IsGroupExecutable( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    return ( ( ( _f->stat_buf.st_mode & S_IRWXG ) == S_IXGRP ) ) ? YES : NO;
}

BOOL XSFile_IsWorldReadable( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    return ( ( ( _f->stat_buf.st_mode & S_IRWXO ) == S_IROTH ) ) ? YES : NO;
}

BOOL XSFile_IsWorldWriteable( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    return ( ( ( _f->stat_buf.st_mode & S_IRWXO ) == S_IWOTH ) ) ? YES : NO;
}

BOOL XSFile_IsWorldExecutable( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    return ( ( ( _f->stat_buf.st_mode & S_IRWXO ) == S_IXOTH ) ) ? YES : NO;
}

BOOL XSFile_HasSUID( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    return ( _f->stat_buf.st_mode & S_ISUID ) ? YES : NO;
}

BOOL XSFile_HasSGID( XSFileRef file )
{
    XSFile * _f;
    
    _f = ( XSFile * )file;
    
    return ( _f->stat_buf.st_mode & S_ISGID ) ? YES : NO;
}
